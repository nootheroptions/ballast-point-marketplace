generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

/// User profile extends Supabase auth.users
model UserProfile {
  id        String   @id @db.Uuid /// The id here matches the Supabase auth user id
  email     String   @unique
  firstName String?  @map("first_name")
  lastName  String?  @map("last_name")
  avatarUrl String?  @map("avatar_url")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  /// Teams the user belongs to (as provider)
  teamMemberships TeamMember[]

  /// Provider onboarding progress (if not completed)
  providerOnboardingProgress ProviderOnboardingProgress?

  @@map("user_profiles")
}

/// Team role for access control
enum TeamRole {
  ADMIN /// Can modify provider profile and manage team members
  MEMBER /// Read-only access to provider profile
}

/// Team groups users who work together on a provider profile
model Team {
  id        String   @id @default(uuid()) @db.Uuid
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  /// The provider profile this team manages
  providerProfile ProviderProfile?
  /// Users who are part of this team
  members         TeamMember[]

  @@map("teams")
}

/// Join table connecting users to teams with roles
model TeamMember {
  id        String   @id @default(uuid()) @db.Uuid
  role      TeamRole @default(MEMBER)
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  user   UserProfile @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String      @map("user_id") @db.Uuid

  team   Team   @relation(fields: [teamId], references: [id], onDelete: Cascade)
  teamId String @map("team_id") @db.Uuid

  /// Booking system relations
  availabilities Availability[]
  participants   BookingParticipant[]

  @@unique([userId, teamId]) /// A user can only be a member of a team once
  @@map("team_members")
}

/// Provider profile for service providers (architecture firms, etc.)
model ProviderProfile {
  id          String  @id @default(uuid()) @db.Uuid
  name        String /// Also used as team name
  slug        String  @unique /// URL-friendly identifier
  description String?
  logoUrl     String? @map("logo_url")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  /// The team that manages this provider profile (1:1 relationship)
  team   Team   @relation(fields: [teamId], references: [id], onDelete: Cascade)
  teamId String @unique @map("team_id") @db.Uuid

  /// Services offered by this provider
  services Service[]

  @@map("provider_profiles")
}

/// Stores partial onboarding progress for users who haven't completed setup
model ProviderOnboardingProgress {
  id          String @id @default(uuid()) @db.Uuid
  currentStep Int    @default(0) @map("current_step") /// 0=intro, 1=step1, 2=step2

  /// Step 1 fields
  name String?
  slug String?

  /// Step 2 fields
  description String?

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  /// The user this onboarding progress belongs to
  user   UserProfile @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String      @unique @map("user_id") @db.Uuid

  @@map("provider_onboarding_progress")
}

/// Services offered by providers
model Service {
  id          String  @id @default(uuid()) @db.Uuid
  name        String
  description String

  /// Slot configuration (minutes)
  slotDuration      Int @default(60) @map("slot_duration") 
  slotBuffer        Int @default(0)  @map("slot_buffer")

  /// Booking window constraints (minutes)
  /// e.g. min = 60 → must book at least 1 hour ahead
  /// max = 43200 → up to 30 days in advance
  advanceBookingMin Int @default(60)     @map("advance_booking_min")
  advanceBookingMax Int @default(43200)  @map("advance_booking_max")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  /// The provider that offers this service
  providerProfile   ProviderProfile @relation(fields: [providerProfileId], references: [id], onDelete: Cascade)
  providerProfileId String          @map("provider_profile_id") @db.Uuid

  availabilities Availability[]
  bookings       Booking[]

  @@map("services")
}

/// =======================================================
/// TEAM MEMBER AVAILABILITY (RECURRING WORKING INTENT)
/// =======================================================
///
/// This model represents *when a team member is willing to work*
/// on a recurring basis.
///
/// IMPORTANT CONCEPTS:
/// - Availability expresses *potential* working time (human intent)
/// - It is NOT a guarantee of availability
/// - It does NOT account for bookings or external calendars
///
/// SERVICE OVERRIDES:
/// - serviceId = NULL → default working hours for the member
/// - serviceId != NULL → member-specific override for that service only
///
/// We intentionally keep availability tied to TeamMember even for
/// service overrides, because availability answers:
///   "Can THIS person work at THIS time for THIS service?"
///
/// Service-wide pauses or shutdowns must NOT be modeled here.
model Availability {
  id           String   @id @default(uuid()) @db.Uuid

  /// 0 = Sunday, 6 = Saturday
  dayOfWeek    Int

  /// Local time in the member's timezone
  startTime    String   /// HH:mm
  endTime      String   /// HH:mm
  timezone     String   /// IANA timezone (e.g. Australia/Sydney)

  teamMemberId String   @db.Uuid @map("team_member_id")
  teamMember   TeamMember @relation(fields: [teamMemberId], references: [id], onDelete: Cascade)

  /// NULL = default member availability
  /// NOT NULL = override for this member when delivering this service
  serviceId    String?  @db.Uuid @map("service_id")
  service      Service? @relation(fields: [serviceId], references: [id], onDelete: Cascade)

  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  @@index([teamMemberId, dayOfWeek])
  @@index([serviceId])
  @@map("availabilities")
}

/// =======================================================
/// BOOKING (EVENT)
/// =======================================================
///
/// IMPORTANT:
/// - A booking does NOT assume a single host
/// - People are attached via BookingParticipant
/// - This supports future expansion without refactors
model Booking {
  id        String   @id @default(uuid()) @db.Uuid

  /// Stored in UTC
  startTime DateTime @map("start_time")
  endTime   DateTime @map("end_time")
  timezone  String   /// Client timezone for display

  status    BookingStatus @default(CONFIRMED)

  notes       String?
  cancelledAt DateTime? @map("cancelled_at")

  serviceId String  @db.Uuid @map("service_id")
  service   Service @relation(fields: [serviceId], references: [id], onDelete: Cascade)

  /// Hosts, co-hosts, invitees
  participants BookingParticipant[]

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@index([serviceId, startTime])
  @@index([status, startTime])
  @@map("bookings")
}

enum BookingStatus {
  CONFIRMED
  CANCELLED
  COMPLETED
  NO_SHOW
}

/// =======================================================
/// BOOKING PARTICIPANT
/// =======================================================
///
/// Represents *any person involved in a booking*.
///
/// CORE DESIGN PRINCIPLES:
/// - A booking is an event
/// - People participate in events with ROLES
/// - Roles define behavior, not table choice
///
/// ROLE SEMANTICS:
/// - HOST / CO_HOST:
///     - Must be linked to a TeamMember
///     - Represents service providers
///
/// - INVITEE:
///     - Represents the client or external attendee
///     - Does NOT require a user account
///     - Identified primarily by email
///
/// IDENTITY RULES:
/// - Exactly ONE of the following must be set:
///     - teamMemberId (for hosts)
///     - userId OR email (for invitees)
///
/// NOTE:
/// - Prisma cannot fully enforce these constraints at schema level
/// - They must be enforced in application logic or database CHECK constraints
model BookingParticipant {
  id String @id @default(uuid()) @db.Uuid

  /// Owning booking
  bookingId String  @db.Uuid @map("booking_id")
  booking   Booking @relation(fields: [bookingId], references: [id], onDelete: Cascade)

  /// Internal participant (hosts / co-hosts)
  teamMemberId String?     @db.Uuid @map("team_member_id")
  teamMember   TeamMember? @relation(fields: [teamMemberId], references: [id], onDelete: Cascade)

  /// Platform user (optional; future-proof)
  /// Example: returning client with an account
  userId String? @db.Uuid @map("user_id")

  /// External invitee identifier
  /// REQUIRED for INVITEE when userId is NULL
  email  String?

  /// Role of the participant in this booking
  role   BookingRole

  /// Per-participant booking state
  status ParticipantStatus @default(ACCEPTED)

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@index([bookingId])
  @@index([teamMemberId])
  @@index([userId])
  @@index([email])
  @@map("booking_participants")
}

enum BookingRole {
  HOST
  CO_HOST
  INVITEE
}

enum ParticipantStatus {
  ACCEPTED
  DECLINED
  NO_SHOW
}
