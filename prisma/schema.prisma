generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

/// User profile extends Supabase auth.users
model UserProfile {
  id        String   @id @db.Uuid /// The id here matches the Supabase auth user id
  email     String   @unique
  firstName String?  @map("first_name")
  lastName  String?  @map("last_name")
  avatarUrl String?  @map("avatar_url")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  /// Teams the user belongs to (as provider)
  teamMemberships TeamMember[]

  /// Provider onboarding progress (if not completed)
  providerOnboardingProgress ProviderOnboardingProgress?

  @@map("user_profiles")
}

/// Team role for access control
enum TeamRole {
  ADMIN /// Can modify provider profile and manage team members
  MEMBER /// Read-only access to provider profile
}

/// Team groups users who work together on a provider profile
model Team {
  id        String   @id @default(uuid()) @db.Uuid
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  /// The provider profile this team manages
  providerProfile ProviderProfile?
  /// Users who are part of this team
  members         TeamMember[]

  @@map("teams")
}

/// Join table connecting users to teams with roles
model TeamMember {
  id        String   @id @default(uuid()) @db.Uuid
  role      TeamRole @default(MEMBER)
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  user   UserProfile @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String      @map("user_id") @db.Uuid

  team   Team   @relation(fields: [teamId], references: [id], onDelete: Cascade)
  teamId String @map("team_id") @db.Uuid

  /// Booking system relations
  availabilities Availability[]
  participants   BookingParticipant[]

  @@unique([userId, teamId]) /// A user can only be a member of a team once
  @@map("team_members")
}

/// Provider profile for service providers (architecture firms, etc.)
model ProviderProfile {
  id          String  @id @default(uuid()) @db.Uuid
  name        String /// Also used as team name
  slug        String  @unique /// URL-friendly identifier
  description String?
  logoUrl     String? @map("logo_url")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  /// The team that manages this provider profile (1:1 relationship)
  team   Team   @relation(fields: [teamId], references: [id], onDelete: Cascade)
  teamId String @unique @map("team_id") @db.Uuid

  /// Services offered by this provider
  services Service[]
  /// Bundles offered by this provider
  bundles  Bundle[]

  @@map("provider_profiles")
}

/// Stores partial onboarding progress for users who haven't completed setup
model ProviderOnboardingProgress {
  id          String @id @default(uuid()) @db.Uuid
  currentStep Int    @default(0) @map("current_step") /// 0=intro, 1=step1, 2=step2

  /// Step 1 fields
  name String?
  slug String?

  /// Step 2 fields
  description String?

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  /// The user this onboarding progress belongs to
  user   UserProfile @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String      @unique @map("user_id") @db.Uuid

  @@map("provider_onboarding_progress")
}

/// Template keys for marketplace services
enum TemplateKey {
  CONSULTATION
  FEASIBILITY
  CONCEPT_DESIGN
  PLANNING_APPROVALS
  REVIEW
}

/// Delivery mode for services
enum DeliveryMode {
  REMOTE
  ON_SITE
  BOTH
}

/// Services offered by providers
/// Supports both marketplace listings AND booking/scheduling
model Service {
  id          String  @id @default(uuid()) @db.Uuid
  name        String
  slug        String  /// URL-friendly identifier, unique per provider
  description String

  /// =======================================================
  /// MARKETPLACE FIELDS
  /// =======================================================

  /// Template this service is based on
  templateKey TemplateKey @map("template_key")

  /// Template-specific configuration stored as JSON
  /// Structure varies by template (e.g., CONSULTATION has duration, delivery, focus)
  templateData Json @map("template_data")

  /// Coverage package identifier (references hardcoded coverage packages in code)
  /// Format: "{templateKey}_{packageKey}" (e.g., "CONSULTATION_STANDARD", "FEASIBILITY_BASIC")
  coveragePackageKey String? @map("coverage_package_key")

  /// Price in cents (AUD)
  priceCents Int @map("price_cents")

  /// Lead time in days (how far in advance must be booked)
  leadTimeDays Int @map("lead_time_days")

  /// Turnaround time in days (delivery time once started)
  turnaroundDays Int @map("turnaround_days")

  /// Delivery mode (remote, on-site, or both)
  deliveryMode DeliveryMode @map("delivery_mode")

  /// Published status (only published services appear in marketplace)
  isPublished Boolean @default(false) @map("is_published")

  /// Short positioning text (e.g., "Best for...")
  positioning String?

  /// Provider assumptions (character-limited note from structured presets + optional free-text)
  assumptions String?

  /// Client responsibilities (stored as JSON array)
  clientResponsibilities Json? @map("client_responsibilities")

  /// =======================================================
  /// BOOKING/SCHEDULING FIELDS (legacy, optional)
  /// =======================================================

  /// Slot configuration (minutes)
  slotDuration      Int @map("slot_duration")
  slotBuffer        Int @map("slot_buffer")

  /// Booking window constraints (minutes)
  advanceBookingMin Int @map("advance_booking_min")
  advanceBookingMax Int @map("advance_booking_max")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  /// The provider that offers this service
  providerProfile   ProviderProfile @relation(fields: [providerProfileId], references: [id], onDelete: Cascade)
  providerProfileId String          @map("provider_profile_id") @db.Uuid

  /// Booking/scheduling relations
  availabilities Availability[]
  bookings       Booking[]

  /// Marketplace relations
  addOns         ServiceAddOn[]
  bundleServices BundleService[]

  @@unique([providerProfileId, slug]) /// Slug must be unique within a provider
  @@map("services")
}

/// =======================================================
/// TEAM MEMBER AVAILABILITY (RECURRING WORKING INTENT)
/// =======================================================
///
/// This model represents *when a team member is willing to work*
/// on a recurring basis.
///
/// IMPORTANT CONCEPTS:
/// - Availability expresses *potential* working time (human intent)
/// - It is NOT a guarantee of availability
/// - It does NOT account for bookings or external calendars
///
/// SERVICE OVERRIDES:
/// - serviceId = NULL → default working hours for the member
/// - serviceId != NULL → member-specific override for that service only
///
/// We intentionally keep availability tied to TeamMember even for
/// service overrides, because availability answers:
///   "Can THIS person work at THIS time for THIS service?"
///
/// Service-wide pauses or shutdowns must NOT be modeled here.
model Availability {
  id           String   @id @default(uuid()) @db.Uuid

  /// 0 = Sunday, 6 = Saturday
  dayOfWeek    Int

  /// Local time in the member's timezone
  startTime    String   /// HH:mm
  endTime      String   /// HH:mm
  timezone     String   /// IANA timezone (e.g. Australia/Sydney)

  teamMemberId String   @db.Uuid @map("team_member_id")
  teamMember   TeamMember @relation(fields: [teamMemberId], references: [id], onDelete: Cascade)

  /// NULL = default member availability
  /// NOT NULL = override for this member when delivering this service
  serviceId    String?  @db.Uuid @map("service_id")
  service      Service? @relation(fields: [serviceId], references: [id], onDelete: Cascade)

  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  @@index([teamMemberId, dayOfWeek])
  @@index([serviceId])
  @@map("availabilities")
}

/// =======================================================
/// BOOKING (EVENT)
/// =======================================================
///
/// IMPORTANT:
/// - A booking does NOT assume a single host
/// - People are attached via BookingParticipant
/// - This supports future expansion without refactors
model Booking {
  id        String   @id @default(uuid()) @db.Uuid

  /// Stored in UTC
  startTime DateTime @map("start_time")
  endTime   DateTime @map("end_time")
  timezone  String   /// Client timezone for display

  status    BookingStatus @default(CONFIRMED)

  notes       String?
  cancelledAt DateTime? @map("cancelled_at")

  serviceId String  @db.Uuid @map("service_id")
  service   Service @relation(fields: [serviceId], references: [id], onDelete: Cascade)

  /// Hosts, co-hosts, invitees
  participants BookingParticipant[]

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@index([serviceId, startTime])
  @@index([status, startTime])
  @@map("bookings")
}

enum BookingStatus {
  CONFIRMED
  CANCELLED
  COMPLETED
  NO_SHOW
}

/// =======================================================
/// BOOKING PARTICIPANT
/// =======================================================
///
/// Represents *any person involved in a booking*.
///
/// CORE DESIGN PRINCIPLES:
/// - A booking is an event
/// - People participate in events with ROLES
/// - Roles define behavior, not table choice
///
/// ROLE SEMANTICS:
/// - HOST / CO_HOST:
///     - Must be linked to a TeamMember
///     - Represents service providers
///
/// - INVITEE:
///     - Represents the client or external attendee
///     - Does NOT require a user account
///     - Identified primarily by email
///
/// IDENTITY RULES:
/// - Exactly ONE of the following must be set:
///     - teamMemberId (for hosts)
///     - userId OR email (for invitees)
///
/// NOTE:
/// - Prisma cannot fully enforce these constraints at schema level
/// - They must be enforced in application logic or database CHECK constraints
model BookingParticipant {
  id String @id @default(uuid()) @db.Uuid

  /// Owning booking
  bookingId String  @db.Uuid @map("booking_id")
  booking   Booking @relation(fields: [bookingId], references: [id], onDelete: Cascade)

  /// Internal participant (hosts / co-hosts)
  teamMemberId String?     @db.Uuid @map("team_member_id")
  teamMember   TeamMember? @relation(fields: [teamMemberId], references: [id], onDelete: Cascade)

  /// Platform user (optional; future-proof)
  /// Example: returning client with an account
  userId String? @db.Uuid @map("user_id")

  /// External invitee identifier
  /// REQUIRED for INVITEE when userId is NULL
  email  String?

  /// Optional display name (primarily for external invitees)
  name   String?

  /// Role of the participant in this booking
  role   BookingRole

  /// Per-participant booking state
  status ParticipantStatus @default(ACCEPTED)

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@index([bookingId])
  @@index([teamMemberId])
  @@index([userId])
  @@index([email])
  @@map("booking_participants")
}

enum BookingRole {
  HOST
  CO_HOST
  INVITEE
}

enum ParticipantStatus {
  ACCEPTED
  DECLINED
  NO_SHOW
}

/// =======================================================
/// MARKETPLACE MODELS
/// =======================================================

/// Bundle pricing type
enum BundlePricingType {
  SUM_OF_PARTS /// Total price = sum of individual service prices
  FIXED /// Fixed bundle price (potentially discounted)
}

/// Join table for services and add-ons with pricing
/// Add-on types are defined in code, this table stores provider selections + pricing
model ServiceAddOn {
  id String @id @default(uuid()) @db.Uuid

  /// Add-on key (references add-on definition in code)
  addOnKey String @map("add_on_key")

  /// Price for this add-on when attached to this service (cents)
  priceCents Int @map("price_cents")

  /// Impact on turnaround time (days, can be negative for expedited)
  turnaroundImpactDays Int @default(0) @map("turnaround_impact_days")

  service   Service @relation(fields: [serviceId], references: [id], onDelete: Cascade)
  serviceId String  @map("service_id") @db.Uuid

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@unique([serviceId, addOnKey])
  @@map("service_add_ons")
}

/// Bundles are curated, ordered sets of services
model Bundle {
  id          String  @id @default(uuid()) @db.Uuid
  name        String
  slug        String  /// URL-friendly identifier, unique per provider
  description String

  /// Pricing configuration
  pricingType   BundlePricingType @map("pricing_type")

  /// If pricingType = FIXED, this is the bundle price
  /// If pricingType = SUM_OF_PARTS, this should be 0
  priceCents Int @default(0) @map("price_cents")

  /// Published status
  isPublished Boolean @default(false) @map("is_published")

  /// Short positioning text
  positioning String?

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  /// The provider that offers this bundle
  providerProfile   ProviderProfile @relation(fields: [providerProfileId], references: [id], onDelete: Cascade)
  providerProfileId String          @map("provider_profile_id") @db.Uuid

  /// Relations
  services BundleService[]
  addOns   BundleAddOn[]

  @@unique([providerProfileId, slug])
  @@map("bundles")
}

/// Join table for bundles and services (maintains order)
model BundleService {
  id String @id @default(uuid()) @db.Uuid

  /// Order of this service in the bundle (0-indexed)
  /// Must follow template stage order
  sortOrder Int @map("sort_order")

  bundle   Bundle @relation(fields: [bundleId], references: [id], onDelete: Cascade)
  bundleId String @map("bundle_id") @db.Uuid

  service   Service @relation(fields: [serviceId], references: [id], onDelete: Cascade)
  serviceId String  @map("service_id") @db.Uuid

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@unique([bundleId, serviceId]) /// Each service can only appear once in a bundle
  @@map("bundle_services")
}

/// Join table for bundles and add-ons with pricing
/// Add-on types are defined in code, this table stores provider selections + pricing
model BundleAddOn {
  id String @id @default(uuid()) @db.Uuid

  /// Add-on key (references add-on definition in code)
  addOnKey String @map("add_on_key")

  /// Price for this add-on when attached to this bundle (cents)
  priceCents Int @map("price_cents")

  /// Impact on turnaround time (days)
  turnaroundImpactDays Int @default(0) @map("turnaround_impact_days")

  bundle   Bundle @relation(fields: [bundleId], references: [id], onDelete: Cascade)
  bundleId String @map("bundle_id") @db.Uuid

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@unique([bundleId, addOnKey])
  @@map("bundle_add_ons")
}
